经典闭包问题




###等号比较

一、基本规则
如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不都是对象，

在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较

所以在使用相等操作符的时候，会有以下情况：

'55' == 55;       //true
false == 0;       //true
"wise" == 3;      //false （ Number("wise") -> NaN ）
[] == 0;          //true  （ Number([]) -> 0 ）



但是在特殊情况下，也就是两边都有对象的时候，会产生看似不合理的结果：

NaN == NaN;  //false 如果有一个操作数是 NaN，无论另一个操作数是什么，相等操作符都返回 false；
[] == [];    //false
[] == ![];   //true
{} == {};    //false
{} == !{};   //false

二、[] == [] 和 {} == {}

在 JavaScript 中，Object、Array、Function、RegExp、Date 都是引用类型

声明引用类型的时候，变量名保存在 js 的栈内存里面，而对应的值保存在堆内存里面

而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针

var a = {};
var b = {};

上面的代码中，声明变量 a 的时候，在堆内存中存储了一个 Object，而 a 实际保存的这个 Object 的地址

然后声明变量 b 的时候，又存储了一个新的 Object

虽然 a 和 b 都保存了一个 Object，但这是两个独立的 Object，它们的地址是不同的

再结合前面的第5条规则：如果两个对象指向同一个对象，相等操作符返回 true

所以 {} == {} 的结果是 false，同样的， [] == [] 的结果也是 false

var c = b;
b == c;   //true（变量c保存的是b的指针，它们指向同一个对象）

三、[] == ![] 和 {} == !{}

参考链接：JavaScript 运算符优先级

ECMAScript 中规定，逻辑非 (!) 的优先级高于相等操作符 ( == )

在比较 [] == ![] 的时候，先计算 ![] 得到布尔值 false

所以实际上比较的是 [] == false

然后根据上面的第1条规则和第3条规则，将两个操作数转为数值类型：

Number([]) == Number(false);   // ->  0 == 0  ->  true



在比较 {} == !{} 的时候，也是遵守同样的规则：

{} == !{}  ->  {} == false  ->  Number({}) == Number(false)  ->  NaN == 0

然后第4条规则规定：如果有一个操作数是 NaN，相等操作符返回 false

所以 {} == !{} 的结果是 false